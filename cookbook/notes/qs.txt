Q1. Explain the difference between deep copy and shallow copy in Python.


üîπ Shallow Copy
Definition: Creates a new outer object but does not copy the nested (inner) objects.
Instead, it copies references to the same inner objects.
So, if you modify a nested object, the change will be
reflected in both the original and the shallow copy.
Tools to create:
copy.copy(obj) from the copy module
Some built-in methods like list.copy() or slicing list[:]


üîπ Deep Copy
Definition: Creates a completely independent copy of the entire object hierarchy.
It recursively copies all nested objects.
So, changes in one object never affect the other.
Tools to create: copy.deepcopy(obj) from the copy module

Exceptions: 
1. Immutable types (like int, str, tuple of immutables):
Don‚Äôt need deep copies; they‚Äôre safe to share.
Shallow and deep behave the same because they can‚Äôt be mutated anyway.

2. Tuples with mutable objects inside:
Shallow copy will copy the tuple, but inner mutable elements are shared.

---------------------------------------------

Q2. What are Python‚Äôs data model ‚Äúdunder‚Äù methods 
(__iter__, __enter__, __exit__, __call__, etc.) and how have you used them?

Dunder methods (short for double underscore) are special methods with names
like __method__. They are hooks into Python‚Äôs data model that let you define
how your objects behave with:

  built-in functions (len, iter, str, etc.)
  operators (+, ==, <, etc.)
  context managers (with)
  iteration protocols, callable behavior, and more
  They allow you to make your custom classes behave like built-in types.

Object Lifecycle
__new__
__init__
__del__

Representation
__repr__
__str__
__format__

Attribute Access
__getattr__
__getattribute__
__setattr__
__delattr__
__dir__

Container Protocol
__len__
__getitem__
__setitem__
__delitem__
__contains__
__iter__
__next__
__reversed__

Callable / Truthiness

__call__
__bool__

Comparisons
__eq__
__ne__
__lt__
__le__
__gt__
__ge__

Arithmetic
__add__, __radd__
__sub__, __rsub__
__mul__, __rmul__
__truediv__, __rtruediv__
__floordiv__, __mod__, __pow__

Context Managers
__enter__
__exit__

Miscellaneous
__index__
__hash__
__copy__, __deepcopy__

---------------------------------------------

Q3. How does the Global Interpreter Lock (Global Interpreter Lock) 
affect multi-threaded Python code?

The Global Interpreter Lock (GIL) in Python (specifically in CPython,
the reference implementation) is a mutex that protects access to Python objects,
preventing multiple native threads from executing Python bytecodes simultaneously.
Its existence has important implications for multi-threaded Python code:

Effect on CPU-bound code
CPU-bound code performs heavy computations in Python
 (e.g., numeric calculations, parsing, or algorithmic processing).
Because the GIL allows only one thread to execute Python bytecode at a time,
multi-threading does not result in a performance boost for CPU-bound tasks.
In some cases, context switching between threads can even make performance worse.


Effect on I/O-bound code
I/O-bound code waits for external resources (disk I/O, network requests, database queries).
While one thread is waiting for I/O, the GIL is released, allowing other threads to run.
In this case, multi-threading can improve performance, because threads spend less time idle.

Alternatives to bypass the GIL

If you need true parallelism for CPU-bound tasks, you can:
Use multiprocessing: Each process has its own Python interpreter and GIL

Use C extensions or libraries that release the GIL:
NumPy, SciPy, or custom C extensions can release the GIL during heavy computation.

-----------------------------------------------

Q4. Explain the difference between mutable and immutable objects and give examples.

Mutable objects are objects whose state or contents can be changed after they
are created. You can modify, add, or remove elements without creating a new object.
Examples in Python:
list
dict
set
bytearray


Immutable objects are objects whose state or contents cannot be changed
once created. Any operation that tries to modify it will create a new object instead.
Examples in Python:
int
float
str
tuple
frozenset

Ex. Notice that after append or assignment,
my_list still refers to the same object in memory, just with modified content.
Ex. Here, calling .upper() doesn‚Äôt change my_string; it produces a new string object.

Mutable objects are efficient for frequent modifications.
Immutable objects are safer for data that shouldn‚Äôt change 
(helps avoid bugs and makes objects hashable, so they can be used
as dictionary keys or set elements)

-----------------------------------------------
Q5. What are generators and coroutines? When would you prefer them over lists
or regular functions?

A generator is a special kind of iterator in Python that produces values lazily,
i.e., one at a time, only when requested. This allows you to handle large sequences
efficiently without storing everything in memory.

How to create generators:
Using a generator function with yield.
Using generator expressions (like list comprehensions but with parentheses).


How would you optimize memory usage in a large data processing Python application?

- yield pauses the function and returns a value; it can resume where it left off.
- Unlike a list, it does not store all values in memory.
- Each value is computed on demand.

When to prefer generators over lists:

Memory efficiency: When generating a large sequence that doesn‚Äôt fit in memory.
Lazy evaluation: When you only need part of a sequence at a time.
Pipeline processing: When chaining operations like reading a file line by line.

A coroutine is a function that can pause and resume,
like a generator, but it‚Äôs mainly used for asynchronous programming
or for cooperative multitasking. Coroutines can receive values from
the caller using .send() and can also yield results.

-----------------------------------------------
Q6. How a JIT Compiler Works

JIT compilation is used in languages like Java, C#, 
and sometimes Python (via PyPy) ‚Äî it compiles code while
the program is running, not before.

How a JIT Compiler Works


Source Code (high-level)
        ‚Üì
Bytecode / Intermediate Representation (IR)
        ‚Üì
Runtime detects "hot" code (frequently used)
        ‚Üì
JIT Compiler translates IR ‚Üí Machine Code on the fly
        ‚Üì
Machine Code is cached and executed directly by CPU

Benefit: Starts quickly like an interpreter,
then speeds up hot code like a compiler.


C++ uses Ahead-of-time compilation (AOT), 
meaning code is fully compiled before running.

Multiple .cpp (source) + .h (headers)
        ‚Üì (Compile individually)
      .o / .obj files (machine code objects)
        ‚Üì (Linker combines them)
      Executable (.exe / .out) + linked libraries
        ‚Üì
         Run directly on CPU

The compiler translates each .cpp into object files.
The linker combines them + any 
static/dynamic libraries (.a/.so or .lib/.dll).

Result is a standalone binary.

Python is mostly interpreted, but has an intermediate step:
it compiles to bytecode (.pyc) which runs on the CPython interpreter.

Python .py files
        ‚Üì (Bytecode compiler)
      .pyc bytecode files
        ‚Üì (Interpreter executes)
   Python Virtual Machine (PVM)
        ‚Üì
   Instructions translated to machine operations at runtime


No separate "linking" step.
If using PyPy or similar, a JIT may convert hot code paths
to machine code during runtime to speed things up.
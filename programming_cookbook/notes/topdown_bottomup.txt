
Top-Down vs Bottom-Up Dynamic Programming

1. Top-Down DP (Memoization)

Idea: Start with the original problem and recursively
break it into smaller subproblems, storing results to
avoid recomputation.

Characteristics:
* Recursion-based.
* Solves subproblems only when needed.
* Uses memoization (cache/dictionary/array).
* Usually easier to write if you already have a recursive solution.

Example: Fibonacci (top-down)

```python
memo = {}
def fib_top_down(n):
    if n in memo:
        return memo[n]
    if n == 0:
        return 0
    if n == 1:
        return 1
    memo[n] = fib_top_down(n-1) + fib_top_down(n-2)
    return memo[n]

print(fib_top_down(10))  # Output: 55
```

Complexity:
* Time: O(n)
* Space: O(n) (memo + recursion stack)

Visual: Think recursion tree where repeated calls are avoided by memoization.


2. Bottom-Up DP (Tabulation)

Idea: Solve smaller subproblems first, and use their solutions
to build up to the original problem.

Characteristics:
* Iterative approach.
* Solves all subproblems up to n, even if some are not strictly needed.
* Usually more space-efficient (can reduce stack usage).

Example: Fibonacci (bottom-up)
```python
def fib_bottom_up(n):
    if n == 0:
        return 0
    a, b = 0, 1
    for _ in range(1, n):
        a, b = b, a + b
    return b

print(fib_bottom_up(10))  # Output: 55
```
Complexity:
* Time: O(n)
* Space: O(1) (or O(n) if storing the whole table)

Visual: Imagine filling a table from index 0 to n, then reading the last value.


3. Comparison Table

| Feature             | Top-Down (Memoization)                       | Bottom-Up (Tabulation)          |
| ------------------- | -------------------------------------------- | ------------------------------- |
| Approach            | Recursive                                    | Iterative                       |
| Order of solving    | Start with original problem, solve as needed | Start with smallest subproblems |
| Space complexity    | O(n) (memo + recursion stack)                | O(1)â€“O(n)                       |
| Ease of writing     | Easier if you know recursion                 | Slightly more work upfront      |
| Problem suitability | Sparse subproblems (not all needed)          | When all subproblems are needed |

Key takeaway: Both achieve the same time complexity, but top-down is natural if 
you have a recursive solution, while bottom-up is often more efficient in practice,
especially with space.



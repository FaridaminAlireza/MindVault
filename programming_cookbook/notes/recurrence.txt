Divide-and-Conquer recurrence

For a divide-and-conquer algorithm, the recurrence is typically written as:

T(n) = a * T(n/b) + O(n^d)

Where:

* a = number of subproblems
* n/b = size of each subproblem
* O(n^d) = cost of dividing and combining at each level (outside of recursive calls)

n^d represents the non-recursive work per level. 
This includes operations like splitting, merging, adding, or combining subproblem results.
* Example: In Merge Sort, merging two sorted halves costs O(n). Here, d = 1, so n^d = n.
* Example: In Strassen’s matrix multiplication, combining matrices via addition/subtraction
  costs O(n^2), so d = 2, n^d = n^2.

2. n^d is independent of a and b.
* a (number of subproblems) determines how many recursive calls are made per level.
* b (division factor) determines the size of each subproblem.
* n^d only represents the cost of combining at the current level.

Recursion tree example (Merge Sort):

| Level  | # subproblems | Size per subproblem | Work per node | Total work per level |
| ------ | ------------- | ------------------- | ------------- | -------------------- |
| 0      | 1             | n                   | n             | n                    |
| 1      | 2             | n/2                 | n/2           | 2*(n/2)=n            |
| 2      | 4             | n/4                 | n/4           | 4*(n/4)=n            |
| ...    | ...           | ...                 | ...           | ...                  |
| log2 n | n             | 1                   | 1             | n                    |


T(n) = 2 * T(n/2) + O(n)
T(n/2) = 2 * T*(n/4) + O(n/2)
...

* Total work per level is always n^d = n (for Merge Sort, d=1).
* The exponent d is from the combining step, not the number of recursive calls.

Another example (Strassen’s Matrix Multiplication):

* Recurrence: T(n) = 7T(n/2) + O(n^2)
* a = 7 (number of subproblems)
* b = 2 (division factor)
* d = 2 (cost of combining matrices)
* Here n^d = n^2 represents the addition/subtraction cost at each level.

---------------------------------------------------------
--> Solving Recurrence for merge sort by induction reasoning:

Recurrence: T(n) = 2T(n/2) + n

For merge sort, we use the identity: T(n) = 2^i * T(n / 2^i) + i * n

Proof by Induction for the Merge Sort Expansion Identity:

1. Base case (i = 0):
When i = 0 the identity becomes: T(n) = 2^0 * T(n / 2^0) + 0 * n = T(n) + 0,
which is trivially true.

2. Inductive step:
Assume the identity holds for i = k (inductive hypothesis): T(n) = 2^k * T(n / 2^k) + k * n.
We must show it holds for i = k + 1.

Start from the recurrence: T(n) = 2 * T(n/2) + n. Apply the inductive hypothesis
to the subproblem T(n/2) by replacing n with n/2 in the hypothesis:

T(n/2) = 2^k * T((n/2) / 2^k) + k * (n/2)
       = 2^k * T(n / 2^(k+1)) + (k * n) / 2.

Substitute this expression for T(n/2) into the recurrence for T(n):

T(n) = 2 * [ 2^k * T(n / 2^(k+1)) + (k * n) / 2 ] + n
     = 2^(k+1) * T(n / 2^(k+1)) + k * n + n
     = 2^(k+1) * T(n / 2^(k+1)) + (k + 1) * n.


This proves the identity for i = k + 1.

By mathematical induction the identity holds for all integers i >= 0.
Applying the identity until the recursion bottoms out.

Choose i such that n / 2^i = 1, 
i.e. 2^i = n, so i = log_2(n) (for n a power of two).
Substitute i = log_2(n):

T(n) = 2^(log_2 n) * T(1) + (log_2 n) * n
     = n * T(1) + n * log_2 n.


If the base cost T(1) = c, then
T(n) = n * c + n * log_2 n = n * (log_2 n + c),
which implies the asymptotic result T(n) = Θ(n log n).

Recursion Tree View Example for n = 16

| Level      | # of Subproblems | Size per Subproblem | Work per Node | Total Work per Level |
| ---------- | ---------------- | ------------------- | ------------- | -------------------- |
| 0          | 1                | 16                  | 16            | 16                   |
| 1          | 2                | 8                   | 8             | 16                   |
| 2          | 4                | 4                   | 4             | 16                   |
| 3          | 8                | 2                   | 2             | 16                   |
| 4 (leaves) | 16               | 1                   | T(1) = c      | 16c                  |

Total internal (merge) work = 16 + 16 + 16 + 16 = 64
Leaf work = 16c

T(16) = 16c + 64
If c = 1, T(16) = 80

For n = 16, total merge work = 64, base work = 16c, total = 16c + 64.

---------------------------------------------------------
--> Master Theorem:
The same pattern generalizes to the recurrence T(n) = a T(n/b) + f(n);
 repeated substitution yields the general expanded form

  T(n) = a^i * T(n / b^i) + sum_{j=0}^{i-1} a^j * f(n / b^j),
  which forms the basis for the Master Theorem.
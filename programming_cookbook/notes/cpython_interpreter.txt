Programming Language Execution Models and Internals

This document summarizes the execution steps, type systems,
and interpreter/virtual machine internals for
Python (CPython, PyPy), Java, and C++.


1. Python (CPython)

1.1 Execution Pipeline

1. Source Code (`.py`) â†’ Compilation to Bytecode (`.pyc`) automatically
 when the script is run.
2. PVM (Python Virtual Machine) executes the bytecode.
3. CPU executes the compiled C code of the interpreter, not the Python
 bytecode directly.

1.2 Interpreter Loop

* Python uses a stack-based virtual machine (PVM).
* Bytecode instructions are executed one at a time in a
 C-level interpreter loop.

* Example of loop (simplified C):
```c
for (;;) {
    opcode = NEXT_INSTRUCTION();
    switch(opcode) {
        case LOAD_CONST: ...;
        case BINARY_ADD: ...;
        ...
    }
}
```

1.3 Python Stack

* Managed entirely in C, separate from CPU stack.
* Array of `PyObject*` pointers.
* Instructions push/pop objects from this stack.

Example:

```python
z = (x + y) * w
```

Bytecode (simplified):

```
LOAD_NAME x
LOAD_NAME y
BINARY_ADD
LOAD_NAME w
BINARY_MULTIPLY
STORE_NAME z
```

* Each operation pushes/pops Python objects to/from the stack
